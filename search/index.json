[{"content":"我们都知道 errno，是存放系统调用错误的地方，其位于 \u0026lt;errno.h\u0026gt; 中，但是 它到底是怎么来的？系统是在什么时候设置的这个值的？毕竟系统调用 syscall 只会返回 -1 来表示当前系统调用出错……\n实际上，在使用系统调用的时候，我们通过一系列 syscall 获取的返回值是已经被 libc 覆写过的了\nShow me the code https://codebrowser.dev/glibc/glibc/sysdeps/unix/sysv/linux/riscv/syscall.c.html#30\n这里我们以 risc-v 架构上的代码为例，我们可以看到 syscall 的具体实现:\nlong int syscall (long int syscall_number, long int arg1, long int arg2, long int arg3, long int arg4, long int arg5, long int arg6, long int arg7) { long int ret; ret = INTERNAL_SYSCALL_NCS_CALL (syscall_number, arg1, arg2, arg3, arg4, arg5, arg6, arg7); if (INTERNAL_SYSCALL_ERROR_P (ret)) return __syscall_error (ret); return ret; } 这里有个宏 INTERNAL_SYSCALL_ERROR_P，其展开后是 ((unsigned long int) (val) \u0026gt; -4096UL)\n这里 -4096UL 的十六进制是 FFFF FFFF FFFF F000\n我们可以看到实际内核态执行的 syscall 的返回值就是 errno，只不过被 libc 包装了一下\n将 errno 的值设置到了线程全局变量 __libc_errno 中，之后用户态的 errno 实际是个读取 __libc_errno 的宏\n总结 libc 检查系统调用是否失败，失败后会设置 errno，之后返回的值是 -1\n可以看到 __syscall_error 的具体实现:\nENTRY (__syscall_error) mv t0, ra /* Fall through to __syscall_set_errno. */ END (__syscall_error) /* Non-standard calling convention: argument in a0, return address in t0, and clobber only t1. */ ENTRY (__syscall_set_errno) /* We got here because a0 \u0026lt; 0, but only codes in the range [-4095, -1] represent errors. Otherwise, just return the result normally. */ li t1, -4096 bleu a0, t1, 1f neg a0, a0 #if RTLD_PRIVATE_ERRNO sw a0, rtld_errno, t1 #elif defined(__PIC__) la.tls.ie t1, errno add t1, t1, tp sw a0, 0(t1) #else lui t1, %tprel_hi(errno) add t1, t1, tp, %tprel_add(errno) sw a0, %tprel_lo(errno)(t1) #endif li a0, -1 1:\tjr t0 END (__syscall_set_errno) ","date":"2023-07-08","permalink":"https://sslime336.github.io/post/when-did-errno-been-set/","tags":["c","linux","errno"],"title":"errno 到底是个啥"},{"content":" 本文源自某乎 https://www.zhihu.com/question/20482511/answer/15262336\n所谓强制转换，其实也分不同的类型。一个强制转换语句，在不同的场合下，有不同的含义。大体上来看，在 C 语言里面，强制类型转换有两种含义:\n1，将一个数据，复制为另外一个数据类型，并且使用新类型的数据，此时可以认为新类型的数据， 在内存结构方面与原有数据没有任何关系，这是实实在在的发生了转换，而且执行这个转换相关的代码是编译器生成的\n例如:\nchar c = 'c'; int i = (int) c; 在上面的例子中，字符 c 被转化成了 int，两者是完全不同的数据，其内存占用的长度也完全不同\n2，将一个数据，当作另外一个数据类型使用，让编译器认为这就是另外一个数据类型，此时数据没有发生任何转换， 在计算机的角度没有任何事情发生，也不为这个转换生成任何代码，只是编译器认为这个语句合法了\n例如:\nlong l = 0x10000000L; volatile void *p = (void *) l; 在这句话中，变量 l 被直接视为指针 p，从内存数据的角度没有发生任何转换，这个转换只是让编译器认为 这个赋值合法而已\n在 C++ 里面，通常第二种类型被称为 reinterpret_cast， 而第一种类型就直接使用显式类型转换实现\n在 Java 里面，通常也会根据上下文，出现 1 和 2 的两种不同情况\n","date":"2023-07-05","permalink":"https://sslime336.github.io/post/the-price-of-type-casting/","tags":["misc"],"title":"强制类型转换的代价"},{"content":"函数的调用约定包括了函数的参数如何被压入栈中、函数调用后由谁来恢复堆栈等问题1\n常见的调用约定2 调用约定名称 常见场景 参数入栈方式 栈内数据清除方式 备注 __stdcall Windows API 默认的函数调用协议 函数参数由右向左入栈 函数调用结束后由被调用函数清除栈内数据 - __cdecl C/C++ 默认的函数调用协议 函数参数由右向左入栈 函数调用结束后由函数调用者清除栈内数据 - __fastcall 适用于对性能要求较高的场合 从左开始不大于 4 字节的参数放入 CPU 的 ECX 和 EDX 寄存器，其余参数从右向左入栈 函数调用结束后由被调用函数清除栈内数据 - __thiscall C++ 类成员函数缺省的调用约定 函数参数由右向左入栈 见下文 这个不是编译器关键字，在 C++ 编译中不能被程序员指定 naked call 很少见，一般用于实模式驱动程序设计3 - - - __pascal4 Pascal 的函数调用方式，也可以在 C/C++ 中使用 函数参数由左向右入栈 函数调用结束后由被调用函数清除栈内数据 - __thiscall 看了不少博客，但还是看巨硬的文档比较详细: https://learn.microsoft.com/zh-cn/cpp/cpp/thiscall?view=msvc-170\nmangle 不同的规范有不同的 mangle 规定，这也是 C 和 C++ 函数之间不能直接调用的原因\n所以一般会有下面这种语法:\nextern \u0026quot;C\u0026quot; { // ... } 这样里面的函数声明才能被 C 所使用，或使用 C 定义的函数\nhttps://learn.microsoft.com/zh-cn/cpp/cpp/calling-conventions?view=msvc-170\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://www.cnblogs.com/yejianyong/p/7506465.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://blog.csdn.net/mlyjqx/article/details/73844565\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://blog.csdn.net/qq_40851561/article/details/114107965\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-07-05","permalink":"https://sslime336.github.io/post/func-call-convention/","tags":["__stdcall","__fastcall"],"title":"函数调用约定"},{"content":"Rust 中有一个方便的注解 #[linkage]，这是一个不稳定的 feature，网上关于它的 信息基本找不到，在我搜索半天后，在 Github 上找到了一个 tracking issue: rust-lang/rust issue#29603\n目前 Rust 支持的链接模型1 Rust 是基于 LLVM 的，所以使用的也是 LLVM 的链接模型\nmatch name { \u0026quot;appending\u0026quot; =\u0026gt; Some(llvm::AppendingLinkage), \u0026quot;available_externally\u0026quot; =\u0026gt; Some(llvm::AvailableExternallyLinkage), \u0026quot;common\u0026quot; =\u0026gt; Some(llvm::CommonLinkage), \u0026quot;extern_weak\u0026quot; =\u0026gt; Some(llvm::ExternalWeakLinkage), \u0026quot;external\u0026quot; =\u0026gt; Some(llvm::ExternalLinkage), \u0026quot;internal\u0026quot; =\u0026gt; Some(llvm::InternalLinkage), \u0026quot;linkonce\u0026quot; =\u0026gt; Some(llvm::LinkOnceAnyLinkage), \u0026quot;linkonce_odr\u0026quot; =\u0026gt; Some(llvm::LinkOnceODRLinkage), \u0026quot;private\u0026quot; =\u0026gt; Some(llvm::PrivateLinkage), \u0026quot;weak\u0026quot; =\u0026gt; Some(llvm::WeakAnyLinkage), \u0026quot;weak_odr\u0026quot; =\u0026gt; Some(llvm::WeakODRLinkage), _ =\u0026gt; None, } 相关的值会转换成 LLVM 的链接，而 LLVM 现在的链接器还没有稳定，用的还是 gcc 的链接器?\ne.g.\n#[linkage = \u0026quot;weak\u0026quot;] #[no_mangle] fn main() -\u0026gt; ! { ... } LLVM 中不同的链接属性2 All Global Variables and Functions have one of the following types of linkage:\nprivate\nGlobal values with “private” linkage are only directly accessible by objects in the current module. In particular, linking code into a module with a private global value may cause the private to be renamed as necessary to avoid collisions. Because the symbol is private to the module, all references can be updated. This doesn’t show up in any symbol table in the object file.\ninternal\nSimilar to private, but the value shows as a local symbol (STB_LOCAL in the case of ELF) in the object file. This corresponds to the notion of the ‘static’ keyword in C.\navailable_externally\nGlobals with “available_externally” linkage are never emitted into the object file corresponding to the LLVM module. From the linker’s perspective, an available_externally global is equivalent to an external declaration. They exist to allow inlining and other optimizations to take place given knowledge of the definition of the global, which is known to be somewhere outside the module. Globals with available_externally linkage are allowed to be discarded at will, and allow inlining and other optimizations. This linkage type is only allowed on definitions, not declarations.\nlinkonce\nGlobals with “linkonce” linkage are merged with other globals of the same name when linkage occurs. This can be used to implement some forms of inline functions, templates, or other code which must be generated in each translation unit that uses it, but where the body may be overridden with a more definitive definition later. Unreferenced linkonce globals are allowed to be discarded. Note that linkonce linkage does not actually allow the optimizer to inline the body of this function into callers because it doesn’t know if this definition of the function is the definitive definition within the program or whether it will be overridden by a stronger definition. To enable inlining and other optimizations, use “linkonce_odr” linkage.\nweak\n“weak” linkage has the same merging semantics as linkonce linkage, except that unreferenced globals with weak linkage may not be discarded. This is used for globals that are declared “weak” in C source code.\ncommon\n“common” linkage is most similar to “weak” linkage, but they are used for tentative definitions in C, such as “int X;” at global scope. Symbols with “common” linkage are merged in the same way as weak symbols, and they may not be deleted if unreferenced. common symbols may not have an explicit section, must have a zero initializer, and may not be marked ‘constant’. Functions and aliases may not have common linkage.\nappending\n“appending” linkage may only be applied to global variables of pointer to array type. When two global variables with appending linkage are linked together, the two global arrays are appended together. This is the LLVM, typesafe, equivalent of having the system linker append together “sections” with identical names when .o files are linked.\nUnfortunately this doesn’t correspond to any feature in .o files, so it can only be used for variables like llvm.global_ctors which llvm interprets specially.\nextern_weak\nThe semantics of this linkage follow the ELF object file model: the symbol is weak until linked, if not linked, the symbol becomes null instead of being an undefined reference.\nlinkonce_odr, weak_odr\nSome languages allow differing globals to be merged, such as two functions with different semantics. Other languages, such as C++, ensure that only equivalent globals are ever merged (the “one definition rule” — “ODR”). Such languages can use the linkonce_odr and weak_odr linkage types to indicate that the global will only be merged with equivalent globals. These linkage types are otherwise the same as their non-odr versions.\nexternal\nIf none of the above identifiers are used, the global is externally visible, meaning that it participates in linkage and can be used to resolve external symbol references.\nIt is illegal for a global variable or function declaration to have any linkage type other than external or extern_weak.\nLLVM 函数调用规范 其他非 LLVM 调用规范\n“ccc” - The C calling convention “fastcc” - The fast calling convention “coldcc” - The cold calling convention “cc 10” - GHC convention “cc 11” - The HiPE calling convention “webkit_jscc” - WebKit’s JavaScript calling convention “anyregcc” - Dynamic calling convention for code patching “preserve_mostcc” - The PreserveMost calling convention “preserve_allcc” - The PreserveAll calling convention “cxx_fast_tlscc” - The CXX_FAST_TLS calling convention for access functions “tailcc” - Tail callable calling convention “swiftcc” - This calling convention is used for Swift language. “swifttailcc” “cfguard_checkcc” - Windows Control Flow Guard (Check mechanism) “cc \u0026lt;n\u0026gt;” - Numbered convention https://github.com/rust-lang/rust/issues/29603#issuecomment-154123326\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://llvm.org/docs/LangRef.html#linkage-types\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-07-05","permalink":"https://sslime336.github.io/post/linkage-feature-in-rust/","tags":["linkage","link","unstable","rust"],"title":"Rust 中的链接 #[linkage = \"xxx\"]"},{"content":"docker 现在默认使用 wsl2，但是这里的 wsl2 并不是用户自己安装的，而是 docker 自己安装的\n而 docker 自己安装的 wsl2 会默认放在 C 盘，所以我们需要手动做一下迁移防止 C 盘爆炸\n有些辅助迁移的软件如: LxRunOffline.exe 是不能够迁移 docker 安装的 wsl2 的，只能作用于 用户自己安装的 wsl2\n所以我们需要以下的命令1(PowerShell 或者 CMD)2:\n# 关闭所有发行版： wsl --shutdown # 将docker-desktop-data导出到D:\\SoftwareData\\wsl\\docker-desktop-data\\docker-desktop-data.tar（注意，原有的docker images不会一起导出） wsl --export docker-desktop-data D:\\SoftwareData\\wsl\\docker-desktop-data\\docker-desktop-data.tar # 注销 docker-desktop-data wsl --unregister docker-desktop-data # 重新导入 docker-desktop-data 到要存放的文件夹：D:\\SoftwareData\\wsl\\docker-desktop-data\\ wsl --import docker-desktop-data D:\\SoftwareData\\wsl\\docker-desktop-data\\ D:\\SoftwareData\\wsl\\docker-desktop-data\\docker-desktop-data.tar --version 2 https://www.cnblogs.com/xhznl/p/13184398.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://github.com/docker/for-win/issues/7348\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-07-04","permalink":"https://sslime336.github.io/post/docker-in-disk-c/","tags":["docker"],"title":"Docker 使用 WSL2 吃满 C 盘空间"},{"content":"本文假定您对 Nim 已经有一定的了解，本文并非零基础教程\n安装🔭 建议的安装姿势: 使用 choosenim\nWindows🖥️ 从这里 https://github.com/dom96/choosenim/releases 下载压缩包(.zip)，不要下载 .exe\nUnix🎵 [Optional] 代表可选\n[CHOOSENIM_CHOOSE_VERSION=stable] curl https://nim-lang.org/choosenim/init.sh -sSf | sh 或者\n[CHOOSENIM_CHOOSE_VERSION=stable] wget -qO - https://nim-lang.org/choosenim/init.sh | sh *可以通过环境变量 CHOOSENIM_CHOOSE_VERSION 来指定安装的版本，默认是最新的发行版\nNote: Nim 也有类似于 Rust 的 nightly 构建，这个构建是基于 devel 的.\n*Nim 虽然已经有相当一段时间的发展，但它仍然是一个小众的社区，所以我个人并不建议使用最新的 nightly(devel) 构建，因为您可能会收获一些无法立刻解决的 bug\n配置⚙️ choosenim 🔧 choosenim 会默认安装到 ~/.choosenim 中，在 Windows 上是 C:\\User\\\u0026lt;Username\u0026gt;\\.\n之后各个版本的工具链会安装这个目录，choosenim 也提供了 --choosenimDir 来指定其安装位置，有兴趣的可以自己试一试.\nnimble 📦 nimble 类似于 Rust 的 cargo，是 Nim 的官方包管理器，在通过 choosenim 安装的时候会一块安装好.\nnimble 的默认安装路径是 ~/.nimble(请自行翻译成 Windows 上的相应目录😋)\n如果有需要，可以通过配置文件来修改默认的包安装路径1:\nWindows: C:\\Users\\\u0026lt;Username\u0026gt;\\AppData\\Roaming\\nimble\\nimble.ini Unix: ~/.config/nimble/nimble.ini 举个栗子🌰:\n# 这是我个人的配置 httpProxy = r\u0026quot;127.0.0.1:7890\u0026quot; # 下载依赖使用的代理 nimbleDir = r\u0026quot;E:\\.nimble\u0026quot; # 默认下载/安装的包放到 E 盘 nim.cfg 🤖 接下来我们需要配置 Nim 的编译器，这个部分之所以存在是因为 Nim 当前的稳定版(昨天还是今天来着，刚从 1.6.12 更新到 1.6.14)仍然使用的是引用计数的 GC(refc)，而非高效的 ARC/ORC\n你可以在 ~/.choosenim/toolchains/ 中找到你正实际使用的 Nim 版本，之后可以修改其配置文件 ./nim-1.6.14/config/nim.cfg:\n# 同理，附上我的配置，只需找个地方加上这个即可 # -------------------------------------------------------------------------- # # User defined by sslime336 # # -------------------------------------------------------------------------- # cc = clang # 使用 LLVM 而非传统 GCC，因为有些包会依赖 libclang，虽然可以直接提供给 # GCC 这个库，但使用 LLVM 相对于 GCC 会带来更好的性能 --gc:arc # 使用 ARC. # ORC 虽然带来了循环引用内存泄露的消除，但是也引入的大多数时候不必要的性能损耗 # 我们需要将修改后的 `nimble` 位置添加进来，不然会找不到依赖 nimblepath=r\u0026quot;E:\\.nimble\\pkgs\u0026quot; nimblepath=r\u0026quot;E:\\.nimble\\pkgs2\u0026quot; # 这里我们根据不同的构建方式，如 -d:release, -d:danger，在指定位置生成带有后缀标记的缓存 # *_r 表示 release 的缓存, *_rd 是 danger，*_d 是默认的 debug 构建的缓存 @if release: nimcache = r\u0026quot;E:\\.cache\\nimcache\\${projectName}_r\u0026quot; @elif danger: nimcache = r\u0026quot;E:\\.cache\\nimcache\\${projectName}_rd\u0026quot; @else # 需要提醒一句的是，虽然 nimc 默认是 debug 构建，但如果不指定 -d:debug，是不会走到 # @elif debug: 中的，所以我们直接使用 @else 来 workaround nimcache = r\u0026quot;E:\\.cache\\nimcache\\${projectName}_d\u0026quot; @end # ---------------------- End of sslime336's define ------------------------- 行了，到这里就差不多了，现在可以:\ntouch helloworld.nim and write some code use nimble init [pkgName] to do whatever you want 未完待续\u0026hellip; https://github.com/nim-lang/nimble#configuration\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-06-28","permalink":"https://sslime336.github.io/post/start-nim-all-in-one/","tags":null,"title":"Nim 一本通(bushi)"},{"content":"首先要说的是，内存排序相对来说比较底层，对于不同的 CPU 硬件设计都有可能不同\nMemory Ordering 针对的是多核(多线程)原子操作的内存连续性(Coherence)和一致性(Consitency)问题\nCoherence 定义了一个读操作能获得什么样的值1 Consitency 定义了何时一个写操作的值会被读操作获得。 为什么会出现内存的一致性/连续性问题 我们知道 CPU 访问主存需要的开销非常大（上 100 个 cycles），如果 CPU 想存储一个数据到 memory 而该数据又不在 data cache 中，则这个过程是相当耗时的，大大地降低了 CPU 性能\n为了进一步加快内存访问速度，CPU 设计中引入了 store buffer 这个部件，store buffer 是位于执行单元(比如浮点执行单元 FPU, 算术逻辑单元 ALU 等)与 data cache 之间的小一块存储单元\n使用 store buffer 的好处不仅在于加快存储的速度，另外还可以利用 store buffer 实现乱序执行 以及实现推断执行(speculative execution)失败后的回退 roll back，等2\n下面是 Rust 官方文档中的内存顺序，根据官网提示，这里并不全:\nNon-exhaustive enums could have additional variants added in future. Therefore, when matching against variants of non-exhaustive enums, an extra wildcard arm must be added to account for any future variants.\n原子内存顺序3 Relaxed\n没有顺序约束，只是原子操作\nRelease/Acquire\n这里 Release 对应写(store)操作，Acquire 对应读(load)操作\n这两这是配合着使用的\n当一个线程 store with Release 写原子类型对象, 而有另一个线程 load with Acquire 度原子类型对象时, 那么在写及写之前的所有写原子操作都是发生在另一个线程中读该原子类型之后的所有读原子操作之前\nAcqRel\n和前者相同，可以看做一种简写，对于读(load)采用 Acquire，对于写(store)采用 Release\nSeqCst\n若某一原子类型对象在不同线程中使用 SeqCst 读写, 那么该原子操作之前的所有读写原子操作都先于该原子操作之后的读写操作\nFurion W. 在回答\u0026quot;如何理解 C++11 的六种 memory order？\u0026quot;. https://www.zhihu.com/question/24301047/answer/83422523\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nshawn. 内存一致性(Memory Consistency). https://zhuanlan.zhihu.com/p/422848235?utm_id=0\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nmengsuenyan. Rust Ordering 语义理解. https://www.cnblogs.com/mengsuenyan/p/13043691.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-06-13","permalink":"https://sslime336.github.io/post/memory-order/","tags":["memory order","todo"],"title":"Rust Memory Ordering"},{"content":"可以通过 #[cfg(debug_assertions)] 和 #[cfg(not(debug_assertions))] 来控制\nReference: https://doc.rust-lang.org/reference/conditional-compilation.html#debug_assertions\nfn main() { #[cfg(not(debug_assertions))] println!(\u0026quot;release mode build\u0026quot;); #[cfg(debug_assertions)] println!(\u0026quot;debug mode build\u0026quot;); } # 输出: release mode build cargo r --release # 输出: debug mode build cargo r ","date":"2023-06-13","permalink":"https://sslime336.github.io/post/rust-notes1/","tags":["rust"],"title":"Rust 配置在 debug/release 构建中的不同表现"},{"content":"今天在写汇编的时候发现我的 VSC 出现了一种恶心的 tab 补全现象\nTABLE: DB 3FH,06H,5BH,4FH,66H ; 0 1 2 3 4 ^ | 当我紧贴着 0 敲击 tab 的时候，它没有插入制表符或是空格，而是把 0 补全成了 0000H，我知道这是我之前设置的补全选项，但是忘了在哪了，现在记录一下免得再犯傻(x)\nSettings \u0026ndash;\u0026gt; 搜索 tab \u0026ndash;\u0026gt; 找到 Editor: Tab Completion \u0026ndash;\u0026gt; 设置为 off\n仔细看一下 on 的描述:\nTab complete will insert the best matching suggestion when pressing tab.\n所以还是不要乱设置看起来很 nice 但不特别需要的 feature 了吧 qwq\n","date":"2023-06-05","permalink":"https://sslime336.github.io/post/vsc-tab-completiom/","tags":["vscode","code-completion"],"title":"VSCode tab completion"},{"content":"在 git commit 的时候，默认的编辑器是 GNU nano，但对于重度 vim 用户来说，还是 vim 用的顺手(x)\n这时候可以通过 git config --global core.editor vi 来修改全局默认的 commit 编辑器\nvi 和 vim 的区别? vim 兼容 vi，是后者的升级版\nvim的这些优势主要体现在以下几个方面：\n1、多级撤消\n我们知道在vi里，按 u只能撤消上次命令，而在vim里可以无限制的撤消。\n2、易用性\nvi只能运行于unix中，而vim不仅可以运行于unix,windows ,mac等多操作平台。\n3、语法加亮\nvim可以用不同的颜色来加亮你的代码。\n4、可视化操作\n就是说vim不仅可以在终端运行，也可以运行于x window、 mac os、 windows。\n\u0026hellip;\u0026hellip;\nvi和vim都是Linux中的编辑器，不同的是vim比较高级，可以视为vi的升级版本。vi使用于文本编辑，但是vim更适用于coding\n摘自: https://www.cnblogs.com/KiraEXA/p/5994078.html\n","date":"2023-06-04","permalink":"https://sslime336.github.io/post/change-git-default-editor/","tags":["git","vi/vim","GNU nano"],"title":"更改 git 默认编辑器"},{"content":"Linux 备忘录(bushi)\nLinux 各目录作用 摘录自: https://www.runoob.com/linux/linux-system-contents.html\n/bin:\nbin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。\n/boot:\n这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。\n/dev :\ndev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。\n/etc:\netc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。\n/home:\n用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。\n/lib:\nlib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。\n/lost+found:\n这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。\n/media:\nlinux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。\n/mnt:\n系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 - /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。\n/opt:\nopt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。\n/proc:\nproc 是 Processes(进程) 的缩写，- /proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。\n这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器:\necho 1 \u0026gt; - /proc/sys/net/ipv4/icmp_echo_ignore_all /root:\n该目录为系统管理员，也称作超级权限者的用户主目录。\n/sbin:\ns 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。\n/selinux:\n这个目录是 Redhat- /CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。\n/srv:\n该目录存放一些服务启动之后需要提取的数据。\n/sys:\n这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。\nsysfs 文件系统集成了下面3种文件系统的信息:针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。\n该文件系统是内核设备树的一个直观反映。\n当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。\n/tmp:\ntmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。\n/usr:\nusr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。\n/usr/bin:\n系统用户使用的应用程序。\n/usr/sbin:\n超级用户使用的比较高级的管理程序和系统守护程序。\n/usr/src:\n内核源代码默认的放置目录。\n/var:\nvar 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。\n/run:\n是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。\n在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。\n/etc:\n上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。\n/var:\n这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 /var/log 目录下，另外 mail 的预设放置也是在这里\n/bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在 /bin/ls 目录下的。\n值得提出的是 /bin、/usr/bin 是给系统用户使用的指令（除 root 外的通用用户），而/sbin, /usr/sbin 则是给 root 使用的指令。\n","date":"2023-06-04","permalink":"https://sslime336.github.io/post/linux-notes1/","tags":["notes","linux"],"title":"Linux 小记(一)"},{"content":"这个问题主要涉及到函数传值，但具体是传值还是传引用对于 Nim 来说并不好说，编译器会尽量采用更高效的方式\n如果选用不同的 GC 策略，那么可能又是另一回事(比如 ARC/ORC 可能根据上下文来说就是移动语义)\n这里只简单的考虑非常普通的参数传递情况\n下面是个例子:\ntype Person = object name: string age: Natural proc intro(person: Person) = echo person.repr when isMainModule: var p = Person(name: \u0026quot;John\u0026quot;, age: 100) intro(p) 上面我们定义了一个 Person 类型，我们可以通过 sizeof 来查看它的大小:\necho \u0026quot;sizeof(Person): \u0026quot; \u0026amp; $sizeof(Person) \u0026amp; \u0026quot; Bytes\u0026quot; 结果如下:\nsizeof(Person): 24 Bytes 可以看到当前的 Person 相对来说还是比较小的\n接下来我们看一下调用 intro 时，变量 p 是如何传递的(下面是 C 代码的表示，为了方便看，我删掉了 mangle 的内容):\n注: 我使用的官方编译器，所以会先编译出 C 代码，我配置的 C 编译器是 clang (如果你使用 nlvm 走 LLVM-IR 路线，那么这篇文章可能不是很适合这种情况，这里我们只讨论 nimc 的表现情况及结果)\nstatic const NimStringV2 name = {4, (NimStrPayload*)\u0026amp;{ 4 | NIM_STRLIT_FLAG, \u0026quot;John\u0026quot; }}; nimZeroMem((void*)(\u0026amp;p), sizeof(Person)); p.name = name; p.age = ((NI) 100); intro(p); 可以看到这里变量 p 的传递直接进行了一次拷贝\n但如果我们对 Person 进行下面的修改:\ntype Person = object name: string age: Natural + padding {.used.}: array[512, int] 我们加入了一个 padding 字段，使现在 Person 的大小变成了 sizeof(Person): 4120 Bytes\n再看一下生成的 C 代码:\nstatic const NimStringV2 name = {4, (NimStrPayload*)\u0026amp;{ 4 | NIM_STRLIT_FLAG, \u0026quot;John\u0026quot; }}; nimZeroMem((void*)(\u0026amp;p), sizeof(Person)); p.name = name; p.age = ((NI) 100); intro((\u0026amp;p)); 可以看到这里只是传递了 p 的地址\n所以 Nim 参数的传递还是比较高效的(doge)\n","date":"2023-06-02","permalink":"https://sslime336.github.io/post/nim-notes2/","tags":["notes","nim"],"title":"Nim 不可变参数传递的优化"},{"content":"一般来说，Rust 的 Docker 镜像可以选择 rust:latest\n但是这并没有提供 rust-nightly 的环境，解决办法有两个:\n在构建前，使用 RUN 执行下面的操作:\nRUN rustup update nightly; rustup default nightly; 因为\nThe Rust installs in the images are managed by rustup\n但这样可能会带来一些潜在的问题，详见 rust-lang/docker-rust/issue#5\n或者使用官方提供的另一个镜像 rustlang/rust:nightly\ndocker pull rustlang/rust:nightly FROM rustlang/rust:nightly # 其他内容... ","date":"2023-06-01","permalink":"https://sslime336.github.io/post/docker-note1/","tags":["rust","docker","Dockerfile","nightly"],"title":"在 Docker 中使用 rust-nightly toolchain 构建"},{"content":"最近搞了个 Termius，但是发现一些快捷键被它吞了？！而不是发送到服务器的 shell 上\n众所周知，Ctrl + L 可以代替 clear，但是在 Termius 里面会打开本地的 shell\n而且类似 Ctrl + P 也无法使用了(血压有点小高)\n解决办法 左上角 Settings -\u0026gt; Shortcuts -\u0026gt; PC hotkeys -\u0026gt; Disabled\n杂鱼❤杂鱼❤~\n","date":"2023-05-31","permalink":"https://sslime336.github.io/post/termius-notes1/","tags":["termius"],"title":"禁用 Termius PC hotkeys"},{"content":"本文简单总结了 tracing 和 tracing-subscriber 的使用，详细内容请参阅官方文档:\ntracing: https://docs.rs/tracing/latest/tracing/index.html tracing-subscriber: https://docs.rs/tracing-subscriber/latest/tracing_subscriber/ tracing 是一个由 tokio 开发并维护 的框架，这个框架用于对 Rust 程序进行检测，收集结构化、事件驱动的诊断信息。\n部分翻译自: https://github.com/tokio-rs/tracing#overview\n该框架虽然是由 tokio 开发并维护的，但其并不需要 tokio 的运行时\n使用方法 对于可执行文件(bin crate) 为了记录一系列事件驱动的 trace，应用程序需要实现一个与 tracing 兼容的信息收集器(collector)\ncollector 实现了一种收集 trace 信息的方式，比如直接将信息结构化输出到 stdout(如使用: info!, debug!, error!)\ntracing 按照 Rust 门面日志库 log 开发，在其依赖项里面我们可以看到这点:\n# tracing/Cargo.toml log = { version = \u0026quot;0.4.17\u0026quot;, optional = true } 上面说到对于具体的 trace，我们需要使用一个 collector 将其收集并处理，对于简单的场景，比如只需要 将 trace 当成日志打印到控制台，我们可以使用 tracing-subscriber 的 fmt 模块:\n先添加依赖:\n# lab-rs/Cargo.toml [dependencies] tracing = \u0026quot;0.1\u0026quot; tracing-subscriber = \u0026quot;0.3.17\u0026quot; use tracing::info; fn main() { // 这里调用 fmt::init() 会装载一个全局的 tracing subscriber 来监听 // 当前发生的事情(events) // // 这里的 subcriber 就是一个 `collector`，只不过这是 `tokio` 官方实现的，如果要 // 实现自己的 `collector`，需要保证其与 `tracing` 兼容，即实现 [`tracing::Subcriber`] tracing_subscriber::fmt::init(); info!(\u0026quot;about to exit main\u0026quot;); } cargo r 一下:\n2023-05-31T09:14:17.211140Z INFO lab_rs: about to exit main 可以看到我们的日志信息被收集并打印到了控制台\n而如果删去 tracing_subscriber::fmt::init();，你会发现什么都没有输出\n注: 如果想要实现自己的 collector 则其需要满足 tracing 的 Subscriber trait\n对于库文件(lib crate) 我们只需要使用 tracing 提供的一系列 marco 和方法就行，不需要使用 subscriber\nLibraries should only rely on the tracing crate and use the provided macros and types to collect whatever information might be useful to downstream consumers.\nSubscriber の Layer，Filter 和 Registry 懒得写了直接看官方文档吧 😛\nLayer \u0026amp; Filter\nRegistry\n举个例子:\n直接拿 ricq 的代码哩\nfn main() { tracing_subscriber::registry() .with(tracing_subscriber::fmt::layer().with_target(true)) .with( tracing_subscriber::filter::Targets::new() .with_target(\u0026quot;ricq\u0026quot;, Level::DEBUG) .with_target(\u0026quot;qrcode_login\u0026quot;, Level::DEBUG) .with_target(\u0026quot;ano\u0026quot;, Level::DEBUG), ) .init(); } 悄咪咪说一句: no_std 真就不如 default-features 好用呗qwq\n","date":"2023-05-31","permalink":"https://sslime336.github.io/post/tracing-subscriber/","tags":["trace","rust","tokio"],"title":"tokio tracing"},{"content":"Privacy-Enhanced Mail 即 .pem\n*.pem 指的是一种采用 base64 编码的文本文件，该后缀文件通常用于存放证书或秘钥， 后两者可 单独分开存放也可放在一起\n大概长这样:\n-----BEGIN RSA PRIVATE KEY----- 5LiN5Lya55yf55qE5pyJ5ZOq5Liq5bCP6YC85bS95a2Q5oOz5bmy5Z2P5LqL5ZCn 77yM5LiN5Lya5ZCn77yM5LiN5Lya5ZCn5LiN5Lya55yf55qE5pyJ5ZOq5Liq5bCP 6YC85bS95a2Q5oOz5bmy5Z2P5LqL5ZCn77yM5LiN5Lya5ZCn77yM5LiN5Lya5ZCn 5LiN5Lya55yf55qE5pyJ5ZOq5Liq5bCP6YC85bS95a2Q5oOz5bmy5Z2P5LqL5ZCn 77yM5LiN5Lya5ZCn77yM5LiN5Lya5ZCn5LiN5Lya55yf55qE5pyJ5ZOq5Liq5bCP 6YC85bS95a2Q5oOz5bmy5Z2P5LqL5ZCn77yM5LiN5Lya5ZCn77yM5LiN5Lya5ZCn 5LiN5Lya55yf55qE5pyJ5ZOq5Liq5bCP6YC85bS95a2Q5oOz5bmy5Z2P5LqL5ZCn 77yM5LiN5Lya5ZCn77yM5LiN5Lya5ZCn5LiN5Lya55yf55qE5pyJ5ZOq5Liq5bCP 6YC85bS95a2Q5oOz5bmy5Z2P5LqL5ZCn77yM5LiN5Lya5ZCn77yM5LiN5Lya5ZCn 5LiN5Lya55yf55qE5pyJ5ZOq5Liq5bCP6YC85bS95a2Q5oOz5bmy5Z2P5LqL5ZCn 77yM5LiN5Lya5ZCn77yM5LiN5Lya5ZCn5LiN5Lya55yf55qE5pyJ5ZOq5Liq5bCP 6YC85bS95a2Q5oOz5bmy5Z2P5LqL5ZCn77yM5LiN5Lya5ZCn77yM5LiN5Lya5ZCn 5LiN5Lya55yf55qE5pyJ5ZOq5Liq5bCP6YC85bS95a2Q5oOz5bmy5Z2P5LqL5ZCn 77yM5LiN5Lya5ZCn77yM5LiN5Lya5ZCn5LiN5Lya55yf55qE5pyJ5ZOq5Liq5bCP 6YC85bS95a2Q5oOz5bmy5Z2P5LqL5ZCn77yM5LiN5Lya5ZCn77yM5LiN5Lya5ZCn 6YKj5Liq5bCP6YC85bS95a2Q5LiN5Lya5piv5L2g5ZCn77yM5LiN5Lya5ZCn5LiN 5Lya5ZCn6YKj5Liq5bCP6YC85bS95a2Q5LiN5Lya5piv5L2g5ZCn4p2k5p2C6bG8 fuKdpOadgumxvH4= -----END RSA PRIVATE KEY----- 不要搞事呦:)\n","date":"2023-05-31","permalink":"https://sslime336.github.io/post/what-is-pem/","tags":["certificate","secret-key","file-extension"],"title":"Privacy-Enhanced Mail"},{"content":" 简单写写0 v0\n需求 一个简单方便操作的个人博客，不需要太多特性，力求简洁 平时记录点学习过的知识点 发牢骚 选型 GitHub Page\n免费，好用，自动部署也方便\nHugo\n操作简单，生成文章速度快，主题模板较为丰富\nfuji\n当前使用的主题\n详细流程(基于 fuji) 建仓库 \u0026lt;username\u0026gt;.github.io.git 拉取到本地，hugo 建站，添加主题 $ git clone \u0026lt;git\u0026gt; \u0026amp;\u0026amp; \\ cd \u0026lt;git_dir\u0026gt; \u0026amp;\u0026amp; \\ git checkout -b hugo \u0026amp;\u0026amp; \\ hugo new site . \u0026amp;\u0026amp; \\ git submodule add https://github.com/dsrkafuu/hugo-theme-fuji.git themes/fuji 根据 fuji 文档简单操作 然后把 exampleSite 复制出来，并修改 config.toml\n复用了一下 exampleSite 里面的东西\n配置自动部署 当前的分支是 hugo，我希望在我往这个分支 push 的时候，能自动构建并将 hugo 生成的静态页部署到主分支(master)\n所以使用了下 GitHub Action(参考了王路飞的知乎):\n# .github/workflows/deploy.yml name: Update sslime336.github.io on: push: branches: - hugo jobs: deploy2master: name: Build \u0026amp; Deploy runs-on: ubuntu-latest steps: - name: Check out source code on branch hugo uses: actions/checkout@v3 with: ref: hugo submodules: recursive # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: latest - name: Build run: hugo - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.ACTION_DEPLOY_KEY }} external_repository: sslime336/sslime336.github.io # Page 仓库 publish_branch: master # Page 仓库的分支 publish_dir: ./public # 静态网页路径 commit_message: ${{ github.event.head_commit.message }} 这里唯一需要注意一下的是 deploy_key: ${{ secrets.ACTION_DEPLOY_KEY }}\n这里使用 external_repository 并不合适，以后再改 :P\n准备自动部署:\n在项目根目录新建 .github/workflows/deploy.yml cp 上面的内容并修改 处理 deploy_key, 点我查看 git add . \u0026amp;\u0026amp; git commit -m \u0026quot;xxx\u0026quot; \u0026amp;\u0026amp; git push -set-upstream origin hugo 当然还是建议主分支写东西然后部署到 gh-pages 分支","date":"2023-05-30","permalink":"https://sslime336.github.io/post/short-intro/","tags":["intro"],"title":"搭建过程"}]